//! Vulnerability scanner connectors.
//!
//! This module provides integrations with vulnerability scanning platforms
//! (Qualys, Tenable, Rapid7) for correlating incidents with known vulnerabilities.

pub mod mock;
pub mod qualys;
pub mod rapid7;
pub mod tenable;

pub use self::mock::MockVulnerabilityScanner;

use crate::{Connector, ConnectorResult};
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Trait for vulnerability scanner connectors.
#[async_trait]
pub trait VulnerabilityScanner: Connector {
    /// Gets vulnerabilities affecting a specific asset.
    async fn get_vulnerabilities_for_asset(
        &self,
        asset_id: &str,
    ) -> ConnectorResult<Vec<Vulnerability>>;

    /// Gets results for a specific scan.
    async fn get_scan_results(&self, scan_id: &str) -> ConnectorResult<ScanResult>;

    /// Gets vulnerabilities discovered since a given time.
    async fn get_recent_vulnerabilities(
        &self,
        since: DateTime<Utc>,
        limit: Option<usize>,
    ) -> ConnectorResult<Vec<Vulnerability>>;

    /// Looks up a specific vulnerability by CVE ID.
    async fn get_vulnerability_by_cve(
        &self,
        cve_id: &str,
    ) -> ConnectorResult<Option<Vulnerability>>;
}

/// A vulnerability finding from a scanner.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Vulnerability {
    /// Unique identifier from the scanner.
    pub id: String,
    /// CVE identifier, if assigned.
    pub cve_id: Option<String>,
    /// Short title / name of the vulnerability.
    pub title: String,
    /// Detailed description.
    pub description: String,
    /// Severity classification.
    pub severity: VulnSeverity,
    /// CVSS base score (0.0 - 10.0).
    pub cvss_score: Option<f32>,
    /// CVSS vector string.
    pub cvss_vector: Option<String>,
    /// IDs of affected assets.
    pub affected_asset_ids: Vec<String>,
    /// Recommended remediation steps.
    pub remediation: Option<String>,
    /// Whether a public exploit is known to exist.
    pub exploit_available: bool,
    /// Whether a vendor patch is available.
    pub patch_available: bool,
    /// When this vulnerability was first detected.
    pub first_seen: DateTime<Utc>,
    /// When this vulnerability was last confirmed.
    pub last_seen: DateTime<Utc>,
    /// Current remediation status.
    pub status: VulnStatus,
}

/// Severity classification for vulnerabilities.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[serde(rename_all = "snake_case")]
pub enum VulnSeverity {
    Informational,
    Low,
    Medium,
    High,
    Critical,
}

impl std::fmt::Display for VulnSeverity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VulnSeverity::Informational => write!(f, "Informational"),
            VulnSeverity::Low => write!(f, "Low"),
            VulnSeverity::Medium => write!(f, "Medium"),
            VulnSeverity::High => write!(f, "High"),
            VulnSeverity::Critical => write!(f, "Critical"),
        }
    }
}

/// Remediation status of a vulnerability.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum VulnStatus {
    Open,
    Remediated,
    Accepted,
    FalsePositive,
}

impl std::fmt::Display for VulnStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VulnStatus::Open => write!(f, "Open"),
            VulnStatus::Remediated => write!(f, "Remediated"),
            VulnStatus::Accepted => write!(f, "Accepted"),
            VulnStatus::FalsePositive => write!(f, "False Positive"),
        }
    }
}

/// Results from a vulnerability scan.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResult {
    /// Unique scan identifier.
    pub scan_id: String,
    /// Human-readable scan name.
    pub scan_name: String,
    /// Current status of the scan.
    pub status: ScanStatus,
    /// When the scan started.
    pub started_at: Option<DateTime<Utc>>,
    /// When the scan completed.
    pub completed_at: Option<DateTime<Utc>>,
    /// Total number of hosts scanned.
    pub total_hosts: usize,
    /// Total vulnerabilities discovered.
    pub vulnerabilities_found: usize,
    /// Count of critical severity findings.
    pub critical_count: usize,
    /// Count of high severity findings.
    pub high_count: usize,
    /// Count of medium severity findings.
    pub medium_count: usize,
    /// Count of low severity findings.
    pub low_count: usize,
}

/// Status of a vulnerability scan.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum ScanStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
}

impl std::fmt::Display for ScanStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ScanStatus::Pending => write!(f, "Pending"),
            ScanStatus::Running => write!(f, "Running"),
            ScanStatus::Completed => write!(f, "Completed"),
            ScanStatus::Failed => write!(f, "Failed"),
            ScanStatus::Cancelled => write!(f, "Cancelled"),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vulnerability_creation_and_serialization() {
        let now = Utc::now();
        let vuln = Vulnerability {
            id: "VULN-001".to_string(),
            cve_id: Some("CVE-2024-1234".to_string()),
            title: "Remote Code Execution in libfoo".to_string(),
            description: "A buffer overflow allows remote code execution.".to_string(),
            severity: VulnSeverity::Critical,
            cvss_score: Some(9.8),
            cvss_vector: Some("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H".to_string()),
            affected_asset_ids: vec!["asset-1".to_string(), "asset-2".to_string()],
            remediation: Some("Update libfoo to version 2.1.0".to_string()),
            exploit_available: true,
            patch_available: true,
            first_seen: now,
            last_seen: now,
            status: VulnStatus::Open,
        };

        let json = serde_json::to_string(&vuln).unwrap();
        let deserialized: Vulnerability = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.id, "VULN-001");
        assert_eq!(deserialized.cve_id, Some("CVE-2024-1234".to_string()));
        assert_eq!(deserialized.severity, VulnSeverity::Critical);
        assert!(deserialized.exploit_available);
        assert_eq!(deserialized.affected_asset_ids.len(), 2);
    }

    #[test]
    fn test_severity_ordering() {
        assert!(VulnSeverity::Critical > VulnSeverity::High);
        assert!(VulnSeverity::High > VulnSeverity::Medium);
        assert!(VulnSeverity::Medium > VulnSeverity::Low);
        assert!(VulnSeverity::Low > VulnSeverity::Informational);
    }

    #[test]
    fn test_severity_display() {
        assert_eq!(format!("{}", VulnSeverity::Critical), "Critical");
        assert_eq!(format!("{}", VulnSeverity::High), "High");
        assert_eq!(format!("{}", VulnSeverity::Medium), "Medium");
        assert_eq!(format!("{}", VulnSeverity::Low), "Low");
        assert_eq!(format!("{}", VulnSeverity::Informational), "Informational");
    }

    #[test]
    fn test_vuln_status_display() {
        assert_eq!(format!("{}", VulnStatus::Open), "Open");
        assert_eq!(format!("{}", VulnStatus::Remediated), "Remediated");
        assert_eq!(format!("{}", VulnStatus::Accepted), "Accepted");
        assert_eq!(format!("{}", VulnStatus::FalsePositive), "False Positive");
    }

    #[test]
    fn test_scan_result_serialization() {
        let now = Utc::now();
        let result = ScanResult {
            scan_id: "SCAN-001".to_string(),
            scan_name: "Weekly Production Scan".to_string(),
            status: ScanStatus::Completed,
            started_at: Some(now),
            completed_at: Some(now),
            total_hosts: 150,
            vulnerabilities_found: 42,
            critical_count: 3,
            high_count: 8,
            medium_count: 15,
            low_count: 16,
        };

        let json = serde_json::to_string(&result).unwrap();
        let deserialized: ScanResult = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.scan_id, "SCAN-001");
        assert_eq!(deserialized.status, ScanStatus::Completed);
        assert_eq!(deserialized.total_hosts, 150);
        assert_eq!(deserialized.critical_count, 3);
    }

    #[test]
    fn test_scan_status_display() {
        assert_eq!(format!("{}", ScanStatus::Pending), "Pending");
        assert_eq!(format!("{}", ScanStatus::Running), "Running");
        assert_eq!(format!("{}", ScanStatus::Completed), "Completed");
        assert_eq!(format!("{}", ScanStatus::Failed), "Failed");
        assert_eq!(format!("{}", ScanStatus::Cancelled), "Cancelled");
    }

    #[test]
    fn test_vulnerability_without_optional_fields() {
        let now = Utc::now();
        let vuln = Vulnerability {
            id: "VULN-002".to_string(),
            cve_id: None,
            title: "Weak cipher detected".to_string(),
            description: "Server supports weak TLS ciphers.".to_string(),
            severity: VulnSeverity::Low,
            cvss_score: None,
            cvss_vector: None,
            affected_asset_ids: vec![],
            remediation: None,
            exploit_available: false,
            patch_available: false,
            first_seen: now,
            last_seen: now,
            status: VulnStatus::Accepted,
        };

        let json = serde_json::to_string(&vuln).unwrap();
        let deserialized: Vulnerability = serde_json::from_str(&json).unwrap();
        assert!(deserialized.cve_id.is_none());
        assert!(deserialized.cvss_score.is_none());
        assert!(deserialized.remediation.is_none());
        assert!(!deserialized.exploit_available);
    }
}
