//! Qualys vulnerability scanner connector.

use async_trait::async_trait;
use chrono::{DateTime, TimeZone, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use tracing::info;

use crate::http::HttpClient;
use crate::traits::{ConnectorConfig, ConnectorError, ConnectorHealth, ConnectorResult};
use crate::Connector;

use super::{
    ScanResult, ScanStatus, VulnSeverity, VulnStatus, Vulnerability, VulnerabilityScanner,
};

/// Configuration for the Qualys connector.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QualysConfig {
    /// Base connector configuration.
    #[serde(flatten)]
    pub connector: ConnectorConfig,
    /// Qualys platform URL (e.g., qualysapi.qualys.com).
    pub platform_url: String,
}

/// Qualys vulnerability scanner connector.
pub struct QualysConnector {
    config: QualysConfig,
    client: HttpClient,
}

impl QualysConnector {
    /// Creates a new Qualys connector.
    pub fn new(mut config: QualysConfig) -> ConnectorResult<Self> {
        if config.connector.base_url.trim().is_empty() {
            config.connector.base_url = format!("https://{}", config.platform_url);
        }

        let client = HttpClient::new(config.connector.clone())?;
        info!(platform = %config.platform_url, "Qualys connector initialized");
        Ok(Self { config, client })
    }

    async fn get_json(&self, path: &str) -> ConnectorResult<Value> {
        let response = self.client.get(path).await?;
        response.json::<Value>().await.map_err(|e| {
            ConnectorError::InvalidResponse(format!("Failed to parse Qualys JSON response: {}", e))
        })
    }

    fn find_value<'a>(root: &'a Value, path: &str) -> Option<&'a Value> {
        let mut cursor = root;
        for part in path.split('.') {
            cursor = cursor.get(part)?;
        }
        Some(cursor)
    }

    fn as_string(root: &Value, paths: &[&str]) -> Option<String> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(s) = value.as_str() {
                    if !s.is_empty() {
                        return Some(s.to_string());
                    }
                }
                if let Some(i) = value.as_i64() {
                    return Some(i.to_string());
                }
                if let Some(u) = value.as_u64() {
                    return Some(u.to_string());
                }
            }
        }
        None
    }

    fn as_f32(root: &Value, paths: &[&str]) -> Option<f32> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(v) = value.as_f64() {
                    return Some(v as f32);
                }
                if let Some(v) = value.as_i64() {
                    return Some(v as f32);
                }
                if let Some(v) = value.as_u64() {
                    return Some(v as f32);
                }
                if let Some(v) = value.as_str().and_then(|v| v.parse::<f32>().ok()) {
                    return Some(v);
                }
            }
        }
        None
    }

    fn as_bool(root: &Value, paths: &[&str]) -> Option<bool> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(b) = value.as_bool() {
                    return Some(b);
                }
                if let Some(i) = value.as_i64() {
                    return Some(i != 0);
                }
                if let Some(s) = value.as_str() {
                    let normalized = s.trim().to_ascii_lowercase();
                    if ["true", "yes", "1"].contains(&normalized.as_str()) {
                        return Some(true);
                    }
                    if ["false", "no", "0"].contains(&normalized.as_str()) {
                        return Some(false);
                    }
                }
            }
        }
        None
    }

    fn as_usize(root: &Value, paths: &[&str]) -> Option<usize> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(v) = value.as_u64() {
                    return Some(v as usize);
                }
                if let Some(v) = value.as_i64() {
                    if v >= 0 {
                        return Some(v as usize);
                    }
                }
                if let Some(v) = value.as_str().and_then(|v| v.parse::<usize>().ok()) {
                    return Some(v);
                }
            }
        }
        None
    }

    fn as_datetime(root: &Value, paths: &[&str]) -> Option<DateTime<Utc>> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(s) = value.as_str() {
                    if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                        return Some(dt.with_timezone(&Utc));
                    }
                    if let Ok(dt) = DateTime::parse_from_str(s, "%Y-%m-%d %H:%M:%S") {
                        return Some(dt.with_timezone(&Utc));
                    }
                    if let Ok(ts) = s.parse::<i64>() {
                        if let Some(dt) = Utc.timestamp_opt(ts, 0).single() {
                            return Some(dt);
                        }
                    }
                }
                if let Some(ts) = value.as_i64() {
                    if ts > 2_000_000_000 {
                        if let Some(dt) = Utc.timestamp_millis_opt(ts).single() {
                            return Some(dt);
                        }
                    }
                    if let Some(dt) = Utc.timestamp_opt(ts, 0).single() {
                        return Some(dt);
                    }
                }
            }
        }
        None
    }

    fn severity_from_score(score: f32) -> VulnSeverity {
        if score >= 9.0 {
            VulnSeverity::Critical
        } else if score >= 7.0 {
            VulnSeverity::High
        } else if score >= 4.0 {
            VulnSeverity::Medium
        } else if score > 0.0 {
            VulnSeverity::Low
        } else {
            VulnSeverity::Informational
        }
    }

    fn parse_severity(root: &Value) -> VulnSeverity {
        if let Some(raw) = Self::as_string(root, &["SEVERITY", "severity", "RISK"]) {
            match raw.to_ascii_lowercase().as_str() {
                "5" | "critical" => return VulnSeverity::Critical,
                "4" | "high" => return VulnSeverity::High,
                "3" | "medium" | "moderate" => return VulnSeverity::Medium,
                "2" | "low" => return VulnSeverity::Low,
                "1" | "0" | "informational" | "info" => return VulnSeverity::Informational,
                _ => {}
            }
        }

        Self::as_f32(
            root,
            &["CVSS3_BASE", "CVSS_BASE", "cvss3_base", "cvss_score"],
        )
        .map(Self::severity_from_score)
        .unwrap_or(VulnSeverity::Informational)
    }

    fn parse_status(root: &Value) -> VulnStatus {
        match Self::as_string(root, &["STATUS", "status", "state"])
            .unwrap_or_else(|| "active".to_string())
            .to_ascii_lowercase()
            .as_str()
        {
            "fixed" | "closed" | "resolved" | "remediated" => VulnStatus::Remediated,
            "accepted" | "risk_accepted" => VulnStatus::Accepted,
            "false_positive" => VulnStatus::FalsePositive,
            _ => VulnStatus::Open,
        }
    }

    fn vulnerability_rows(payload: &Value) -> Vec<(&Value, Option<String>)> {
        let mut rows = Vec::new();

        let direct_paths = [
            "vulnerabilities",
            "data.vulnerabilities",
            "RESPONSE.VULNERABILITY_LIST.VULNERABILITY",
            "HOST_LIST_VM_DETECTION_OUTPUT.RESPONSE.DETECTION_LIST.DETECTION",
            "KNOWLEDGE_BASE_VULN_LIST_OUTPUT.RESPONSE.VULN_LIST.VULN",
        ];

        for path in direct_paths {
            if let Some(values) = Self::find_value(payload, path).and_then(|v| v.as_array()) {
                rows.extend(values.iter().map(|row| (row, None)));
                return rows;
            }
        }

        if let Some(hosts) = Self::find_value(
            payload,
            "HOST_LIST_VM_DETECTION_OUTPUT.RESPONSE.HOST_LIST.HOST",
        )
        .and_then(|v| v.as_array())
        {
            for host in hosts {
                let asset_id = Self::as_string(host, &["ID", "id", "IP"]);
                if let Some(detections) =
                    Self::find_value(host, "DETECTION_LIST.DETECTION").and_then(|v| v.as_array())
                {
                    for detection in detections {
                        rows.push((detection, asset_id.clone()));
                    }
                }
            }
            if !rows.is_empty() {
                return rows;
            }
        }

        if let Some(values) = payload.as_array() {
            rows.extend(values.iter().map(|row| (row, None)));
            return rows;
        }

        if payload.is_object() {
            rows.push((payload, None));
        }

        rows
    }

    fn parse_vulnerability(
        root: &Value,
        fallback_asset: Option<&str>,
        nested_asset: Option<String>,
        idx: usize,
    ) -> Vulnerability {
        let id = Self::as_string(root, &["QID", "id", "vuln_id", "ID"])
            .unwrap_or_else(|| format!("qualys-vuln-{}", idx));

        let cve_id = Self::as_string(root, &["CVE_ID", "cve_id", "cve"]).or_else(|| {
            Self::find_value(root, "CVE_LIST.CVE")
                .and_then(|v| v.as_array())
                .and_then(|arr| arr.first())
                .and_then(|v| v.as_str())
                .map(|s| s.to_string())
        });

        let first_seen = Self::as_datetime(
            root,
            &[
                "FIRST_FOUND_DATETIME",
                "FIRST_FOUND",
                "first_seen",
                "published",
            ],
        )
        .unwrap_or_else(Utc::now);
        let last_seen = Self::as_datetime(
            root,
            &["LAST_FOUND_DATETIME", "LAST_FOUND", "last_seen", "modified"],
        )
        .unwrap_or(first_seen);

        let mut assets = Vec::new();
        if let Some(asset) = fallback_asset {
            assets.push(asset.to_string());
        }
        if let Some(asset) = nested_asset {
            if !assets.contains(&asset) {
                assets.push(asset);
            }
        }
        if let Some(asset) = Self::as_string(root, &["ASSET_ID", "HOST_ID", "IP"]) {
            if !assets.contains(&asset) {
                assets.push(asset);
            }
        }

        let cvss_score = Self::as_f32(root, &["CVSS3_BASE", "CVSS_BASE", "cvss_score"]);

        Vulnerability {
            id,
            cve_id,
            title: Self::as_string(root, &["TITLE", "title", "NAME", "name"])
                .unwrap_or_else(|| "Unnamed vulnerability".to_string()),
            description: Self::as_string(root, &["DIAGNOSIS", "DESCRIPTION", "description"])
                .unwrap_or_else(|| "No description provided".to_string()),
            severity: Self::parse_severity(root),
            cvss_score,
            cvss_vector: Self::as_string(root, &["CVSS3_VECTOR", "CVSS_VECTOR", "cvss_vector"]),
            affected_asset_ids: assets,
            remediation: Self::as_string(root, &["SOLUTION", "REMEDIATION", "solution"]),
            exploit_available: Self::as_bool(root, &["EXPLOITABILITY", "exploit_available"])
                .unwrap_or(false),
            patch_available: Self::as_bool(root, &["PATCHABLE", "patch_available"])
                .unwrap_or(false),
            first_seen,
            last_seen,
            status: Self::parse_status(root),
        }
    }

    fn parse_scan_status(raw: &str) -> ScanStatus {
        match raw.to_ascii_lowercase().as_str() {
            "running" | "launched" => ScanStatus::Running,
            "finished" | "completed" => ScanStatus::Completed,
            "canceled" | "cancelled" => ScanStatus::Cancelled,
            "error" | "failed" => ScanStatus::Failed,
            _ => ScanStatus::Pending,
        }
    }

    fn parse_scan_result(scan_id: &str, payload: Value) -> ScanResult {
        let scan_view = Self::find_value(&payload, "SCAN_LIST_OUTPUT.RESPONSE.SCAN_LIST.SCAN")
            .and_then(|v| v.as_array())
            .and_then(|arr| arr.first())
            .unwrap_or(&payload);

        ScanResult {
            scan_id: Self::as_string(scan_view, &["REF", "ID", "id"])
                .unwrap_or_else(|| scan_id.to_string()),
            scan_name: Self::as_string(scan_view, &["TITLE", "name", "NAME"])
                .unwrap_or_else(|| format!("Scan {}", scan_id)),
            status: Self::as_string(scan_view, &["STATUS", "status"])
                .map(|s| Self::parse_scan_status(&s))
                .unwrap_or(ScanStatus::Pending),
            started_at: Self::as_datetime(scan_view, &["LAUNCH_DATETIME", "start_time", "START"]),
            completed_at: Self::as_datetime(scan_view, &["END_DATETIME", "finished_time", "END"]),
            total_hosts: Self::as_usize(scan_view, &["TARGETS", "total_hosts", "HOSTS"])
                .unwrap_or(0),
            vulnerabilities_found: Self::as_usize(
                scan_view,
                &["VULNS", "vulnerability_count", "TOTAL_VULNERABILITIES"],
            )
            .unwrap_or(0),
            critical_count: Self::as_usize(scan_view, &["CRITICAL", "critical_count"]).unwrap_or(0),
            high_count: Self::as_usize(scan_view, &["HIGH", "high_count"]).unwrap_or(0),
            medium_count: Self::as_usize(scan_view, &["MEDIUM", "medium_count"]).unwrap_or(0),
            low_count: Self::as_usize(scan_view, &["LOW", "low_count"]).unwrap_or(0),
        }
    }
}

#[async_trait]
impl Connector for QualysConnector {
    fn name(&self) -> &str {
        &self.config.connector.name
    }

    fn connector_type(&self) -> &str {
        "vulnerability"
    }

    fn capabilities(&self) -> Vec<String> {
        vec![
            "health_check".to_string(),
            "test_connection".to_string(),
            "get_vulnerabilities".to_string(),
            "get_scan_results".to_string(),
        ]
    }

    async fn health_check(&self) -> ConnectorResult<ConnectorHealth> {
        match self
            .client
            .get("/api/2.0/fo/asset/host/?action=list&truncation_limit=1&output_format=json")
            .await
        {
            Ok(response) if response.status().is_success() => Ok(ConnectorHealth::Healthy),
            Ok(response) if response.status().as_u16() == 401 => Ok(ConnectorHealth::Unhealthy(
                "Authentication failed".to_string(),
            )),
            Ok(response) => Ok(ConnectorHealth::Degraded(format!(
                "Unexpected status code {}",
                response.status()
            ))),
            Err(ConnectorError::ConnectionFailed(err)) => Ok(ConnectorHealth::Unhealthy(err)),
            Err(err) => Ok(ConnectorHealth::Unhealthy(err.to_string())),
        }
    }

    async fn test_connection(&self) -> ConnectorResult<bool> {
        let response = self
            .client
            .get("/api/2.0/fo/asset/host/?action=list&truncation_limit=1&output_format=json")
            .await?;
        Ok(response.status().is_success())
    }
}

#[async_trait]
impl VulnerabilityScanner for QualysConnector {
    async fn get_vulnerabilities_for_asset(
        &self,
        asset_id: &str,
    ) -> ConnectorResult<Vec<Vulnerability>> {
        let path = format!(
            "/api/2.0/fo/asset/host/vm/detection/?action=list&ids={}&output_format=json",
            urlencoding::encode(asset_id)
        );
        let payload = self.get_json(&path).await?;

        Ok(Self::vulnerability_rows(&payload)
            .into_iter()
            .enumerate()
            .map(|(idx, (row, nested_asset))| {
                Self::parse_vulnerability(row, Some(asset_id), nested_asset, idx)
            })
            .collect())
    }

    async fn get_scan_results(&self, scan_id: &str) -> ConnectorResult<ScanResult> {
        let path = format!(
            "/api/2.0/fo/scan/?action=list&scan_ref={}&output_format=json",
            urlencoding::encode(scan_id)
        );
        let payload = self.get_json(&path).await?;
        Ok(Self::parse_scan_result(scan_id, payload))
    }

    async fn get_recent_vulnerabilities(
        &self,
        since: DateTime<Utc>,
        limit: Option<usize>,
    ) -> ConnectorResult<Vec<Vulnerability>> {
        let payload = self
            .get_json("/api/2.0/fo/knowledge_base/vuln/?action=list&output_format=json")
            .await?;

        let mut vulnerabilities: Vec<_> = Self::vulnerability_rows(&payload)
            .into_iter()
            .enumerate()
            .map(|(idx, (row, nested_asset))| {
                Self::parse_vulnerability(row, None, nested_asset, idx)
            })
            .filter(|v| v.last_seen >= since || v.first_seen >= since)
            .collect();

        vulnerabilities.sort_by(|a, b| b.last_seen.cmp(&a.last_seen));

        if let Some(limit) = limit {
            vulnerabilities.truncate(limit);
        }

        Ok(vulnerabilities)
    }

    async fn get_vulnerability_by_cve(
        &self,
        cve_id: &str,
    ) -> ConnectorResult<Option<Vulnerability>> {
        let path = format!(
            "/api/2.0/fo/knowledge_base/vuln/?action=list&cve_ids={}&output_format=json",
            urlencoding::encode(cve_id)
        );

        match self.get_json(&path).await {
            Ok(payload) => {
                let vuln = Self::vulnerability_rows(&payload)
                    .into_iter()
                    .enumerate()
                    .map(|(idx, (row, nested_asset))| {
                        Self::parse_vulnerability(row, None, nested_asset, idx)
                    })
                    .find(|v| {
                        v.cve_id
                            .as_ref()
                            .map(|cve| cve.eq_ignore_ascii_case(cve_id))
                            .unwrap_or(false)
                    });
                Ok(vuln)
            }
            Err(ConnectorError::NotFound(_)) => Ok(None),
            Err(err) => Err(err),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::traits::AuthConfig;
    use std::collections::HashMap;

    fn test_config() -> QualysConfig {
        QualysConfig {
            connector: ConnectorConfig {
                name: "qualys-test".to_string(),
                base_url: "https://qualysapi.qualys.com".to_string(),
                auth: AuthConfig::None,
                timeout_secs: 30,
                max_retries: 0,
                verify_tls: true,
                headers: HashMap::new(),
            },
            platform_url: "qualysapi.qualys.com".to_string(),
        }
    }

    #[test]
    fn test_connector_name() {
        let connector = QualysConnector::new(test_config()).unwrap();
        assert_eq!(connector.name(), "qualys-test");
        assert_eq!(connector.connector_type(), "vulnerability");
    }

    #[test]
    fn test_connector_capabilities() {
        let connector = QualysConnector::new(test_config()).unwrap();
        let caps = connector.capabilities();
        assert!(caps.contains(&"get_vulnerabilities".to_string()));
        assert!(caps.contains(&"get_scan_results".to_string()));
    }

    #[test]
    fn test_parse_detection_payload() {
        let payload = serde_json::json!({
            "QID": "12345",
            "CVE_ID": "CVE-2025-5000",
            "TITLE": "TLS issue",
            "DIAGNOSIS": "Weak protocol",
            "SEVERITY": "4",
            "CVSS3_BASE": 8.1,
            "SOLUTION": "Disable old protocol",
            "FIRST_FOUND_DATETIME": "2025-01-01T00:00:00Z",
            "LAST_FOUND_DATETIME": "2025-01-03T00:00:00Z",
            "PATCHABLE": "1"
        });

        let vuln = QualysConnector::parse_vulnerability(&payload, Some("host-1"), None, 0);
        assert_eq!(vuln.id, "12345");
        assert_eq!(vuln.cve_id.as_deref(), Some("CVE-2025-5000"));
        assert_eq!(vuln.severity, VulnSeverity::High);
        assert_eq!(vuln.affected_asset_ids, vec!["host-1".to_string()]);
        assert!(vuln.patch_available);
    }

    #[test]
    fn test_parse_scan_result_payload() {
        let payload = serde_json::json!({
            "REF": "scan-123",
            "TITLE": "Quarterly scan",
            "STATUS": "Finished",
            "TARGETS": 40,
            "VULNS": 10,
            "CRITICAL": 1,
            "HIGH": 2,
            "MEDIUM": 3,
            "LOW": 4
        });

        let scan = QualysConnector::parse_scan_result("scan-123", payload);
        assert_eq!(scan.scan_id, "scan-123");
        assert_eq!(scan.status, ScanStatus::Completed);
        assert_eq!(scan.total_hosts, 40);
        assert_eq!(scan.low_count, 4);
    }
}
