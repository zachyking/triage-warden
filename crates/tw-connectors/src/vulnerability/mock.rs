//! Mock vulnerability scanner for testing.

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use std::sync::{Arc, Mutex};

use crate::traits::{ConnectorHealth, ConnectorResult};
use crate::Connector;

use super::{ScanResult, VulnSeverity, VulnStatus, Vulnerability, VulnerabilityScanner};

/// Mock vulnerability scanner with configurable responses.
pub struct MockVulnerabilityScanner {
    name: String,
    vulnerabilities: Arc<Mutex<Vec<Vulnerability>>>,
    scan_results: Arc<Mutex<Vec<ScanResult>>>,
    healthy: Arc<Mutex<bool>>,
}

impl MockVulnerabilityScanner {
    /// Creates a new mock scanner.
    pub fn new() -> Self {
        Self {
            name: "mock-vuln-scanner".to_string(),
            vulnerabilities: Arc::new(Mutex::new(Vec::new())),
            scan_results: Arc::new(Mutex::new(Vec::new())),
            healthy: Arc::new(Mutex::new(true)),
        }
    }

    /// Creates a mock scanner with a custom name.
    pub fn with_name(name: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            ..Self::new()
        }
    }

    /// Adds a vulnerability to the mock data.
    pub fn add_vulnerability(&self, vuln: Vulnerability) {
        self.vulnerabilities.lock().unwrap().push(vuln);
    }

    /// Adds a scan result to the mock data.
    pub fn add_scan_result(&self, result: ScanResult) {
        self.scan_results.lock().unwrap().push(result);
    }

    /// Sets whether the mock scanner reports as healthy.
    pub fn set_healthy(&self, healthy: bool) {
        *self.healthy.lock().unwrap() = healthy;
    }

    /// Creates a sample vulnerability for testing.
    pub fn sample_vulnerability(id: &str, severity: VulnSeverity) -> Vulnerability {
        let now = Utc::now();
        Vulnerability {
            id: id.to_string(),
            cve_id: Some(format!("CVE-2024-{}", &id[id.len().saturating_sub(4)..])),
            title: format!("Test Vulnerability {}", id),
            description: format!("Description for vulnerability {}", id),
            severity,
            cvss_score: match severity {
                VulnSeverity::Critical => Some(9.5),
                VulnSeverity::High => Some(7.5),
                VulnSeverity::Medium => Some(5.0),
                VulnSeverity::Low => Some(3.0),
                VulnSeverity::Informational => Some(0.0),
            },
            cvss_vector: None,
            affected_asset_ids: vec!["asset-1".to_string()],
            remediation: Some("Apply vendor patch".to_string()),
            exploit_available: severity == VulnSeverity::Critical,
            patch_available: true,
            first_seen: now,
            last_seen: now,
            status: VulnStatus::Open,
        }
    }
}

impl Default for MockVulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl Connector for MockVulnerabilityScanner {
    fn name(&self) -> &str {
        &self.name
    }

    fn connector_type(&self) -> &str {
        "vulnerability"
    }

    fn capabilities(&self) -> Vec<String> {
        vec![
            "health_check".to_string(),
            "test_connection".to_string(),
            "get_vulnerabilities".to_string(),
            "get_scan_results".to_string(),
        ]
    }

    async fn health_check(&self) -> ConnectorResult<ConnectorHealth> {
        if *self.healthy.lock().unwrap() {
            Ok(ConnectorHealth::Healthy)
        } else {
            Ok(ConnectorHealth::Unhealthy("Mock unhealthy".to_string()))
        }
    }

    async fn test_connection(&self) -> ConnectorResult<bool> {
        Ok(*self.healthy.lock().unwrap())
    }
}

#[async_trait]
impl VulnerabilityScanner for MockVulnerabilityScanner {
    async fn get_vulnerabilities_for_asset(
        &self,
        asset_id: &str,
    ) -> ConnectorResult<Vec<Vulnerability>> {
        let vulns = self.vulnerabilities.lock().unwrap();
        Ok(vulns
            .iter()
            .filter(|v| v.affected_asset_ids.contains(&asset_id.to_string()))
            .cloned()
            .collect())
    }

    async fn get_scan_results(&self, scan_id: &str) -> ConnectorResult<ScanResult> {
        let results = self.scan_results.lock().unwrap();
        results
            .iter()
            .find(|r| r.scan_id == scan_id)
            .cloned()
            .ok_or_else(|| crate::ConnectorError::NotFound(format!("Scan {} not found", scan_id)))
    }

    async fn get_recent_vulnerabilities(
        &self,
        since: DateTime<Utc>,
        limit: Option<usize>,
    ) -> ConnectorResult<Vec<Vulnerability>> {
        let vulns = self.vulnerabilities.lock().unwrap();
        let mut recent: Vec<_> = vulns
            .iter()
            .filter(|v| v.first_seen >= since)
            .cloned()
            .collect();
        if let Some(limit) = limit {
            recent.truncate(limit);
        }
        Ok(recent)
    }

    async fn get_vulnerability_by_cve(
        &self,
        cve_id: &str,
    ) -> ConnectorResult<Option<Vulnerability>> {
        let vulns = self.vulnerabilities.lock().unwrap();
        Ok(vulns
            .iter()
            .find(|v| v.cve_id.as_deref() == Some(cve_id))
            .cloned())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::vulnerability::ScanStatus;

    #[tokio::test]
    async fn test_mock_health_check() {
        let scanner = MockVulnerabilityScanner::new();
        let health = scanner.health_check().await.unwrap();
        assert_eq!(health, ConnectorHealth::Healthy);

        scanner.set_healthy(false);
        let health = scanner.health_check().await.unwrap();
        assert!(matches!(health, ConnectorHealth::Unhealthy(_)));
    }

    #[tokio::test]
    async fn test_mock_get_vulnerabilities_for_asset() {
        let scanner = MockVulnerabilityScanner::new();
        let vuln = MockVulnerabilityScanner::sample_vulnerability("0001", VulnSeverity::Critical);
        scanner.add_vulnerability(vuln);

        let results = scanner
            .get_vulnerabilities_for_asset("asset-1")
            .await
            .unwrap();
        assert_eq!(results.len(), 1);
        assert_eq!(results[0].severity, VulnSeverity::Critical);

        let results = scanner
            .get_vulnerabilities_for_asset("asset-999")
            .await
            .unwrap();
        assert!(results.is_empty());
    }

    #[tokio::test]
    async fn test_mock_get_scan_results() {
        let scanner = MockVulnerabilityScanner::new();
        scanner.add_scan_result(ScanResult {
            scan_id: "SCAN-001".to_string(),
            scan_name: "Test Scan".to_string(),
            status: ScanStatus::Completed,
            started_at: Some(Utc::now()),
            completed_at: Some(Utc::now()),
            total_hosts: 10,
            vulnerabilities_found: 5,
            critical_count: 1,
            high_count: 2,
            medium_count: 1,
            low_count: 1,
        });

        let result = scanner.get_scan_results("SCAN-001").await.unwrap();
        assert_eq!(result.total_hosts, 10);
        assert_eq!(result.critical_count, 1);

        let err = scanner.get_scan_results("SCAN-999").await;
        assert!(err.is_err());
    }

    #[tokio::test]
    async fn test_mock_get_vulnerability_by_cve() {
        let scanner = MockVulnerabilityScanner::new();
        let vuln = MockVulnerabilityScanner::sample_vulnerability("0001", VulnSeverity::High);
        scanner.add_vulnerability(vuln);

        let result = scanner
            .get_vulnerability_by_cve("CVE-2024-0001")
            .await
            .unwrap();
        assert!(result.is_some());
        assert_eq!(result.unwrap().severity, VulnSeverity::High);

        let result = scanner
            .get_vulnerability_by_cve("CVE-2024-9999")
            .await
            .unwrap();
        assert!(result.is_none());
    }

    #[tokio::test]
    async fn test_mock_get_recent_vulnerabilities() {
        let scanner = MockVulnerabilityScanner::new();
        let vuln = MockVulnerabilityScanner::sample_vulnerability("0001", VulnSeverity::Medium);
        scanner.add_vulnerability(vuln);

        let past = Utc::now() - chrono::Duration::hours(1);
        let results = scanner
            .get_recent_vulnerabilities(past, None)
            .await
            .unwrap();
        assert_eq!(results.len(), 1);

        let results = scanner
            .get_recent_vulnerabilities(past, Some(0))
            .await
            .unwrap();
        assert!(results.is_empty());
    }

    #[test]
    fn test_mock_default() {
        let scanner = MockVulnerabilityScanner::default();
        assert_eq!(scanner.name(), "mock-vuln-scanner");
    }

    #[test]
    fn test_mock_with_name() {
        let scanner = MockVulnerabilityScanner::with_name("custom-scanner");
        assert_eq!(scanner.name(), "custom-scanner");
    }

    #[test]
    fn test_sample_vulnerability_severities() {
        let critical =
            MockVulnerabilityScanner::sample_vulnerability("0001", VulnSeverity::Critical);
        assert!(critical.exploit_available);
        assert_eq!(critical.cvss_score, Some(9.5));

        let low = MockVulnerabilityScanner::sample_vulnerability("0002", VulnSeverity::Low);
        assert!(!low.exploit_available);
        assert_eq!(low.cvss_score, Some(3.0));
    }
}
