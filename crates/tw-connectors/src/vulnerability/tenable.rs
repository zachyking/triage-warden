//! Tenable.io vulnerability scanner connector.

use async_trait::async_trait;
use chrono::{DateTime, TimeZone, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use tracing::info;

use crate::http::HttpClient;
use crate::traits::{
    AuthConfig, ConnectorConfig, ConnectorError, ConnectorHealth, ConnectorResult,
};
use crate::Connector;

use super::{
    ScanResult, ScanStatus, VulnSeverity, VulnStatus, Vulnerability, VulnerabilityScanner,
};

/// Configuration for the Tenable.io connector.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TenableConfig {
    /// Base connector configuration.
    #[serde(flatten)]
    pub connector: ConnectorConfig,
    /// Tenable.io access key.
    pub access_key: Option<String>,
    /// Tenable.io secret key.
    pub secret_key: Option<String>,
}

/// Tenable.io vulnerability scanner connector.
pub struct TenableConnector {
    config: TenableConfig,
    client: HttpClient,
}

impl TenableConnector {
    /// Creates a new Tenable.io connector.
    pub fn new(mut config: TenableConfig) -> ConnectorResult<Self> {
        if matches!(config.connector.auth, AuthConfig::None) {
            if let (Some(access_key), Some(secret_key)) =
                (config.access_key.as_ref(), config.secret_key.as_ref())
            {
                config.connector.headers.insert(
                    "x-apikey".to_string(),
                    format!("accessKey={}; secretKey={}", access_key, secret_key),
                );
            }
        }

        let client = HttpClient::new(config.connector.clone())?;
        info!("Tenable.io connector initialized");
        Ok(Self { config, client })
    }

    async fn get_json(&self, path: &str) -> ConnectorResult<Value> {
        let response = self.client.get(path).await?;
        response.json::<Value>().await.map_err(|e| {
            ConnectorError::InvalidResponse(format!("Failed to parse Tenable JSON response: {}", e))
        })
    }

    fn find_value<'a>(root: &'a Value, path: &str) -> Option<&'a Value> {
        let mut cursor = root;
        for part in path.split('.') {
            cursor = cursor.get(part)?;
        }
        Some(cursor)
    }

    fn as_string(root: &Value, paths: &[&str]) -> Option<String> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(s) = value.as_str() {
                    if !s.is_empty() {
                        return Some(s.to_string());
                    }
                }
                if let Some(i) = value.as_i64() {
                    return Some(i.to_string());
                }
                if let Some(u) = value.as_u64() {
                    return Some(u.to_string());
                }
            }
        }
        None
    }

    fn as_bool(root: &Value, paths: &[&str]) -> Option<bool> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(b) = value.as_bool() {
                    return Some(b);
                }
                if let Some(n) = value.as_i64() {
                    return Some(n != 0);
                }
                if let Some(s) = value.as_str() {
                    let normalized = s.trim().to_ascii_lowercase();
                    if ["true", "yes", "y", "1"].contains(&normalized.as_str()) {
                        return Some(true);
                    }
                    if ["false", "no", "n", "0"].contains(&normalized.as_str()) {
                        return Some(false);
                    }
                }
            }
        }
        None
    }

    fn as_f32(root: &Value, paths: &[&str]) -> Option<f32> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(v) = value.as_f64() {
                    return Some(v as f32);
                }
                if let Some(v) = value.as_i64() {
                    return Some(v as f32);
                }
                if let Some(v) = value.as_u64() {
                    return Some(v as f32);
                }
                if let Some(v) = value.as_str().and_then(|v| v.parse::<f32>().ok()) {
                    return Some(v);
                }
            }
        }
        None
    }

    fn as_usize(root: &Value, paths: &[&str]) -> Option<usize> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(v) = value.as_u64() {
                    return Some(v as usize);
                }
                if let Some(v) = value.as_i64() {
                    if v >= 0 {
                        return Some(v as usize);
                    }
                }
                if let Some(v) = value.as_str().and_then(|v| v.parse::<usize>().ok()) {
                    return Some(v);
                }
            }
        }
        None
    }

    fn as_datetime(root: &Value, paths: &[&str]) -> Option<DateTime<Utc>> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(s) = value.as_str() {
                    if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                        return Some(dt.with_timezone(&Utc));
                    }
                    if let Ok(ts) = s.parse::<i64>() {
                        if let Some(dt) = Utc.timestamp_opt(ts, 0).single() {
                            return Some(dt);
                        }
                    }
                }
                if let Some(ts) = value.as_i64() {
                    if ts > 2_000_000_000 {
                        if let Some(dt) = Utc.timestamp_millis_opt(ts).single() {
                            return Some(dt);
                        }
                    }
                    if let Some(dt) = Utc.timestamp_opt(ts, 0).single() {
                        return Some(dt);
                    }
                }
            }
        }
        None
    }

    fn vulnerability_rows(payload: &Value) -> Vec<&Value> {
        let paths = [
            "vulnerabilities",
            "data.vulnerabilities",
            "response.vulnerabilities",
            "data.items",
            "items",
            "results",
        ];

        for path in paths {
            if let Some(values) = Self::find_value(payload, path).and_then(|v| v.as_array()) {
                return values.iter().collect();
            }
        }

        if let Some(values) = payload.as_array() {
            return values.iter().collect();
        }

        if payload.is_object() {
            return vec![payload];
        }

        Vec::new()
    }

    fn parse_severity(root: &Value) -> VulnSeverity {
        let score = Self::as_f32(
            root,
            &[
                "cvss3_base_score",
                "cvss.base_score",
                "cvss_score",
                "severity_score",
            ],
        );

        if let Some(raw) = Self::as_string(root, &["severity", "severity_label", "risk_factor"]) {
            match raw.to_ascii_lowercase().as_str() {
                "critical" | "5" => return VulnSeverity::Critical,
                "high" | "4" => return VulnSeverity::High,
                "medium" | "3" | "moderate" => return VulnSeverity::Medium,
                "low" | "2" => return VulnSeverity::Low,
                "info" | "informational" | "1" | "none" | "0" => {
                    return VulnSeverity::Informational;
                }
                _ => {}
            }
        }

        match score.unwrap_or_default() {
            s if s >= 9.0 => VulnSeverity::Critical,
            s if s >= 7.0 => VulnSeverity::High,
            s if s >= 4.0 => VulnSeverity::Medium,
            s if s > 0.0 => VulnSeverity::Low,
            _ => VulnSeverity::Informational,
        }
    }

    fn parse_status(root: &Value) -> VulnStatus {
        match Self::as_string(root, &["status", "state"])
            .unwrap_or_else(|| "open".to_string())
            .to_ascii_lowercase()
            .as_str()
        {
            "fixed" | "closed" | "remediated" | "resolved" => VulnStatus::Remediated,
            "accepted" | "risk_accepted" => VulnStatus::Accepted,
            "false_positive" | "falsepositive" => VulnStatus::FalsePositive,
            _ => VulnStatus::Open,
        }
    }

    fn parse_vulnerability(
        root: &Value,
        fallback_asset: Option<&str>,
        idx: usize,
    ) -> Vulnerability {
        let id = Self::as_string(root, &["id", "plugin_id", "plugin.id", "vuln_id"])
            .unwrap_or_else(|| format!("tenable-vuln-{}", idx));

        let cve_id = Self::as_string(root, &["cve", "cve_id", "plugin.cve"]).or_else(|| {
            Self::find_value(root, "cves")
                .and_then(|v| v.as_array())
                .and_then(|arr| arr.first())
                .and_then(|first| first.as_str())
                .map(|s| s.to_string())
        });

        let first_seen = Self::as_datetime(
            root,
            &["first_seen", "first_found", "first_observed", "created_at"],
        )
        .unwrap_or_else(Utc::now);
        let last_seen = Self::as_datetime(root, &["last_seen", "last_found", "updated_at"])
            .unwrap_or(first_seen);

        let mut assets = Vec::new();
        if let Some(asset_id) = fallback_asset {
            assets.push(asset_id.to_string());
        }
        if let Some(asset_id) =
            Self::as_string(root, &["asset.uuid", "asset.id", "asset_uuid", "host_id"])
        {
            if !assets.contains(&asset_id) {
                assets.push(asset_id);
            }
        }

        Vulnerability {
            id,
            cve_id,
            title: Self::as_string(root, &["plugin_name", "title", "name"])
                .unwrap_or_else(|| "Unnamed vulnerability".to_string()),
            description: Self::as_string(root, &["description", "plugin_description"])
                .unwrap_or_else(|| "No description provided".to_string()),
            severity: Self::parse_severity(root),
            cvss_score: Self::as_f32(
                root,
                &[
                    "cvss3_base_score",
                    "cvss.base_score",
                    "cvss_score",
                    "severity_score",
                ],
            ),
            cvss_vector: Self::as_string(root, &["cvss3_vector", "cvss_vector", "cvss.vector"]),
            affected_asset_ids: assets,
            remediation: Self::as_string(root, &["solution", "remediation", "fix"]),
            exploit_available: Self::as_bool(
                root,
                &["exploit_available", "exploited_by_malware", "has_exploit"],
            )
            .unwrap_or(false),
            patch_available: Self::as_bool(root, &["patch_available", "has_patch"])
                .unwrap_or(false),
            first_seen,
            last_seen,
            status: Self::parse_status(root),
        }
    }

    fn parse_scan_status(status: &str) -> ScanStatus {
        match status.to_ascii_lowercase().as_str() {
            "running" | "in_progress" => ScanStatus::Running,
            "completed" | "finished" | "done" => ScanStatus::Completed,
            "failed" | "error" => ScanStatus::Failed,
            "cancelled" | "canceled" => ScanStatus::Cancelled,
            _ => ScanStatus::Pending,
        }
    }

    fn parse_scan_result(scan_id: &str, payload: Value) -> ScanResult {
        let scan_view = Self::find_value(&payload, "scan").unwrap_or(&payload);
        let severity_view = Self::find_value(&payload, "severitycount")
            .or_else(|| Self::find_value(scan_view, "severitycount"));

        ScanResult {
            scan_id: Self::as_string(scan_view, &["id", "scan_id"])
                .unwrap_or_else(|| scan_id.to_string()),
            scan_name: Self::as_string(scan_view, &["name", "scan_name"])
                .unwrap_or_else(|| format!("Scan {}", scan_id)),
            status: Self::as_string(scan_view, &["status", "state"])
                .map(|s| Self::parse_scan_status(&s))
                .unwrap_or(ScanStatus::Pending),
            started_at: Self::as_datetime(scan_view, &["starttime", "started_at", "start_time"]),
            completed_at: Self::as_datetime(
                scan_view,
                &["completiontime", "completed_at", "end_time", "finished_at"],
            ),
            total_hosts: Self::as_usize(scan_view, &["total_targets", "total_hosts", "hosts"])
                .unwrap_or(0),
            vulnerabilities_found: Self::as_usize(
                scan_view,
                &["total_vulnerabilities", "vulnerability_count", "vulns"],
            )
            .unwrap_or_else(|| {
                Self::as_usize(&payload, &["total_vulnerabilities", "vulnerability_count"])
                    .unwrap_or(0)
            }),
            critical_count: severity_view
                .and_then(|v| Self::as_usize(v, &["critical", "4"]))
                .unwrap_or_else(|| Self::as_usize(scan_view, &["critical_count"]).unwrap_or(0)),
            high_count: severity_view
                .and_then(|v| Self::as_usize(v, &["high", "3"]))
                .unwrap_or_else(|| Self::as_usize(scan_view, &["high_count"]).unwrap_or(0)),
            medium_count: severity_view
                .and_then(|v| Self::as_usize(v, &["medium", "2"]))
                .unwrap_or_else(|| Self::as_usize(scan_view, &["medium_count"]).unwrap_or(0)),
            low_count: severity_view
                .and_then(|v| Self::as_usize(v, &["low", "1"]))
                .unwrap_or_else(|| Self::as_usize(scan_view, &["low_count"]).unwrap_or(0)),
        }
    }
}

#[async_trait]
impl Connector for TenableConnector {
    fn name(&self) -> &str {
        &self.config.connector.name
    }

    fn connector_type(&self) -> &str {
        "vulnerability"
    }

    fn capabilities(&self) -> Vec<String> {
        vec![
            "health_check".to_string(),
            "test_connection".to_string(),
            "get_vulnerabilities".to_string(),
            "get_scan_results".to_string(),
        ]
    }

    async fn health_check(&self) -> ConnectorResult<ConnectorHealth> {
        match self.client.get("/scanners").await {
            Ok(response) if response.status().is_success() => Ok(ConnectorHealth::Healthy),
            Ok(response) if response.status().as_u16() == 401 => Ok(ConnectorHealth::Unhealthy(
                "Authentication failed".to_string(),
            )),
            Ok(response) => Ok(ConnectorHealth::Degraded(format!(
                "Unexpected status code {}",
                response.status()
            ))),
            Err(ConnectorError::ConnectionFailed(err)) => Ok(ConnectorHealth::Unhealthy(err)),
            Err(err) => Ok(ConnectorHealth::Unhealthy(err.to_string())),
        }
    }

    async fn test_connection(&self) -> ConnectorResult<bool> {
        let response = self.client.get("/scanners").await?;
        Ok(response.status().is_success())
    }
}

#[async_trait]
impl VulnerabilityScanner for TenableConnector {
    async fn get_vulnerabilities_for_asset(
        &self,
        asset_id: &str,
    ) -> ConnectorResult<Vec<Vulnerability>> {
        let path = format!(
            "/workbenches/assets/{}/vulnerabilities",
            urlencoding::encode(asset_id)
        );
        let payload = self.get_json(&path).await?;

        Ok(Self::vulnerability_rows(&payload)
            .into_iter()
            .enumerate()
            .map(|(idx, row)| Self::parse_vulnerability(row, Some(asset_id), idx))
            .collect())
    }

    async fn get_scan_results(&self, scan_id: &str) -> ConnectorResult<ScanResult> {
        let path = format!("/scans/{}", urlencoding::encode(scan_id));
        let payload = self.get_json(&path).await?;
        Ok(Self::parse_scan_result(scan_id, payload))
    }

    async fn get_recent_vulnerabilities(
        &self,
        since: DateTime<Utc>,
        limit: Option<usize>,
    ) -> ConnectorResult<Vec<Vulnerability>> {
        let path = format!(
            "/workbenches/vulnerabilities?date_range={}",
            since.to_rfc3339()
        );

        let payload = self.get_json(&path).await?;
        let mut vulnerabilities: Vec<_> = Self::vulnerability_rows(&payload)
            .into_iter()
            .enumerate()
            .map(|(idx, row)| Self::parse_vulnerability(row, None, idx))
            .filter(|v| v.last_seen >= since || v.first_seen >= since)
            .collect();

        vulnerabilities.sort_by(|a, b| b.last_seen.cmp(&a.last_seen));

        if let Some(limit) = limit {
            vulnerabilities.truncate(limit);
        }

        Ok(vulnerabilities)
    }

    async fn get_vulnerability_by_cve(
        &self,
        cve_id: &str,
    ) -> ConnectorResult<Option<Vulnerability>> {
        let path = format!(
            "/workbenches/vulnerabilities?cve={}",
            urlencoding::encode(cve_id)
        );

        match self.get_json(&path).await {
            Ok(payload) => {
                let vuln = Self::vulnerability_rows(&payload)
                    .into_iter()
                    .enumerate()
                    .map(|(idx, row)| Self::parse_vulnerability(row, None, idx))
                    .find(|v| {
                        v.cve_id
                            .as_ref()
                            .map(|cve| cve.eq_ignore_ascii_case(cve_id))
                            .unwrap_or(false)
                    });
                Ok(vuln)
            }
            Err(ConnectorError::NotFound(_)) => Ok(None),
            Err(err) => Err(err),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    fn test_config() -> TenableConfig {
        TenableConfig {
            connector: ConnectorConfig {
                name: "tenable-test".to_string(),
                base_url: "https://cloud.tenable.com".to_string(),
                auth: AuthConfig::None,
                timeout_secs: 30,
                max_retries: 0,
                verify_tls: true,
                headers: HashMap::new(),
            },
            access_key: None,
            secret_key: None,
        }
    }

    #[test]
    fn test_connector_name() {
        let connector = TenableConnector::new(test_config()).unwrap();
        assert_eq!(connector.name(), "tenable-test");
        assert_eq!(connector.connector_type(), "vulnerability");
    }

    #[test]
    fn test_connector_capabilities() {
        let connector = TenableConnector::new(test_config()).unwrap();
        let caps = connector.capabilities();
        assert!(caps.contains(&"get_vulnerabilities".to_string()));
    }

    #[test]
    fn test_parse_vulnerability_from_payload() {
        let payload = serde_json::json!({
            "id": "vuln-123",
            "cve": "CVE-2024-1000",
            "plugin_name": "Critical RCE",
            "description": "Remote code execution",
            "severity": "critical",
            "cvss3_base_score": 9.8,
            "solution": "Apply patch",
            "exploit_available": true,
            "patch_available": true,
            "first_seen": "2025-01-01T00:00:00Z",
            "last_seen": "2025-01-02T00:00:00Z"
        });

        let vuln = TenableConnector::parse_vulnerability(&payload, Some("asset-1"), 0);
        assert_eq!(vuln.id, "vuln-123");
        assert_eq!(vuln.cve_id.as_deref(), Some("CVE-2024-1000"));
        assert_eq!(vuln.severity, VulnSeverity::Critical);
        assert_eq!(vuln.affected_asset_ids, vec!["asset-1".to_string()]);
        assert!(vuln.exploit_available);
    }

    #[test]
    fn test_parse_scan_result_from_payload() {
        let payload = serde_json::json!({
            "scan": {
                "id": "scan-42",
                "name": "Nightly Scan",
                "status": "completed",
                "starttime": "2025-01-01T00:00:00Z",
                "completiontime": "2025-01-01T01:00:00Z",
                "total_targets": 12,
                "total_vulnerabilities": 5
            },
            "severitycount": {
                "critical": 1,
                "high": 2,
                "medium": 1,
                "low": 1
            }
        });

        let result = TenableConnector::parse_scan_result("scan-42", payload);
        assert_eq!(result.scan_id, "scan-42");
        assert_eq!(result.status, ScanStatus::Completed);
        assert_eq!(result.total_hosts, 12);
        assert_eq!(result.critical_count, 1);
    }

    #[test]
    fn test_config_injects_x_apikey_header() {
        let mut config = test_config();
        config.access_key = Some("access".to_string());
        config.secret_key = Some("secret".to_string());

        let connector = TenableConnector::new(config).unwrap();
        assert_eq!(
            connector.config.connector.headers.get("x-apikey").unwrap(),
            "accessKey=access; secretKey=secret"
        );
    }
}
