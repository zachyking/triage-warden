//! Rapid7 InsightVM vulnerability scanner connector.

use async_trait::async_trait;
use chrono::{DateTime, TimeZone, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use tracing::info;

use crate::http::HttpClient;
use crate::traits::{ConnectorConfig, ConnectorError, ConnectorHealth, ConnectorResult};
use crate::Connector;

use super::{
    ScanResult, ScanStatus, VulnSeverity, VulnStatus, Vulnerability, VulnerabilityScanner,
};

/// Configuration for the Rapid7 InsightVM connector.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Rapid7Config {
    /// Base connector configuration.
    #[serde(flatten)]
    pub connector: ConnectorConfig,
    /// Rapid7 region for InsightVM Cloud.
    pub region: Option<String>,
}

/// Rapid7 InsightVM vulnerability scanner connector.
pub struct Rapid7Connector {
    config: Rapid7Config,
    client: HttpClient,
}

impl Rapid7Connector {
    /// Creates a new Rapid7 InsightVM connector.
    pub fn new(config: Rapid7Config) -> ConnectorResult<Self> {
        let client = HttpClient::new(config.connector.clone())?;
        info!(
            region = config.region.as_deref().unwrap_or("default"),
            "Rapid7 InsightVM connector initialized"
        );
        Ok(Self { config, client })
    }

    async fn get_json(&self, path: &str) -> ConnectorResult<Value> {
        let response = self.client.get(path).await?;
        response.json::<Value>().await.map_err(|e| {
            ConnectorError::InvalidResponse(format!("Failed to parse Rapid7 JSON response: {}", e))
        })
    }

    fn find_value<'a>(root: &'a Value, path: &str) -> Option<&'a Value> {
        let mut cursor = root;
        for part in path.split('.') {
            cursor = cursor.get(part)?;
        }
        Some(cursor)
    }

    fn as_string(root: &Value, paths: &[&str]) -> Option<String> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(s) = value.as_str() {
                    if !s.is_empty() {
                        return Some(s.to_string());
                    }
                }
                if let Some(i) = value.as_i64() {
                    return Some(i.to_string());
                }
                if let Some(u) = value.as_u64() {
                    return Some(u.to_string());
                }
            }
        }
        None
    }

    fn as_f32(root: &Value, paths: &[&str]) -> Option<f32> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(v) = value.as_f64() {
                    return Some(v as f32);
                }
                if let Some(v) = value.as_i64() {
                    return Some(v as f32);
                }
                if let Some(v) = value.as_u64() {
                    return Some(v as f32);
                }
                if let Some(v) = value.as_str().and_then(|v| v.parse::<f32>().ok()) {
                    return Some(v);
                }
            }
        }
        None
    }

    fn as_bool(root: &Value, paths: &[&str]) -> Option<bool> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(b) = value.as_bool() {
                    return Some(b);
                }
                if let Some(i) = value.as_i64() {
                    return Some(i != 0);
                }
                if let Some(s) = value.as_str() {
                    let normalized = s.trim().to_ascii_lowercase();
                    if ["true", "yes", "1"].contains(&normalized.as_str()) {
                        return Some(true);
                    }
                    if ["false", "no", "0"].contains(&normalized.as_str()) {
                        return Some(false);
                    }
                }
            }
        }
        None
    }

    fn as_usize(root: &Value, paths: &[&str]) -> Option<usize> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(v) = value.as_u64() {
                    return Some(v as usize);
                }
                if let Some(v) = value.as_i64() {
                    if v >= 0 {
                        return Some(v as usize);
                    }
                }
                if let Some(v) = value.as_str().and_then(|v| v.parse::<usize>().ok()) {
                    return Some(v);
                }
            }
        }
        None
    }

    fn as_datetime(root: &Value, paths: &[&str]) -> Option<DateTime<Utc>> {
        for path in paths {
            if let Some(value) = Self::find_value(root, path) {
                if let Some(s) = value.as_str() {
                    if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
                        return Some(dt.with_timezone(&Utc));
                    }
                    if let Ok(ts) = s.parse::<i64>() {
                        if let Some(dt) = Utc.timestamp_opt(ts, 0).single() {
                            return Some(dt);
                        }
                    }
                }
                if let Some(ts) = value.as_i64() {
                    if ts > 2_000_000_000 {
                        if let Some(dt) = Utc.timestamp_millis_opt(ts).single() {
                            return Some(dt);
                        }
                    }
                    if let Some(dt) = Utc.timestamp_opt(ts, 0).single() {
                        return Some(dt);
                    }
                }
            }
        }
        None
    }

    fn vulnerability_rows(payload: &Value) -> Vec<&Value> {
        let paths = [
            "resources",
            "vulnerabilities",
            "data.vulnerabilities",
            "data.resources",
            "items",
            "results",
        ];

        for path in paths {
            if let Some(values) = Self::find_value(payload, path).and_then(|v| v.as_array()) {
                return values.iter().collect();
            }
        }

        if let Some(values) = payload.as_array() {
            return values.iter().collect();
        }

        if payload.is_object() {
            return vec![payload];
        }

        Vec::new()
    }

    fn parse_severity(root: &Value) -> VulnSeverity {
        if let Some(raw) = Self::as_string(root, &["severity", "riskScore", "risk_score"]) {
            match raw.to_ascii_lowercase().as_str() {
                "critical" | "very_high" => return VulnSeverity::Critical,
                "high" => return VulnSeverity::High,
                "medium" | "moderate" => return VulnSeverity::Medium,
                "low" => return VulnSeverity::Low,
                "informational" | "info" => return VulnSeverity::Informational,
                _ => {}
            }
        }

        match Self::as_f32(root, &["cvssScore", "cvss.score", "cvss_v3_score"]).unwrap_or_default()
        {
            s if s >= 9.0 => VulnSeverity::Critical,
            s if s >= 7.0 => VulnSeverity::High,
            s if s >= 4.0 => VulnSeverity::Medium,
            s if s > 0.0 => VulnSeverity::Low,
            _ => VulnSeverity::Informational,
        }
    }

    fn parse_status(root: &Value) -> VulnStatus {
        match Self::as_string(root, &["status", "state"])
            .unwrap_or_else(|| "open".to_string())
            .to_ascii_lowercase()
            .as_str()
        {
            "fixed" | "closed" | "remediated" | "resolved" => VulnStatus::Remediated,
            "accepted" | "risk_accepted" => VulnStatus::Accepted,
            "false_positive" => VulnStatus::FalsePositive,
            _ => VulnStatus::Open,
        }
    }

    fn parse_vulnerability(
        root: &Value,
        fallback_asset: Option<&str>,
        idx: usize,
    ) -> Vulnerability {
        let id = Self::as_string(
            root,
            &["id", "vulnerability.id", "vulnerabilityId", "nexpose_id"],
        )
        .unwrap_or_else(|| format!("rapid7-vuln-{}", idx));

        let cve_id = Self::as_string(root, &["cve", "cves.0", "cve_id"]).or_else(|| {
            Self::find_value(root, "cves")
                .and_then(|v| v.as_array())
                .and_then(|arr| arr.first())
                .and_then(|v| v.as_str())
                .map(|s| s.to_string())
        });

        let first_seen = Self::as_datetime(
            root,
            &["firstDiscovered", "first_seen", "first_found", "published"],
        )
        .unwrap_or_else(Utc::now);
        let last_seen = Self::as_datetime(
            root,
            &["lastObserved", "last_seen", "last_found", "modified"],
        )
        .unwrap_or(first_seen);

        let mut assets = Vec::new();
        if let Some(asset_id) = fallback_asset {
            assets.push(asset_id.to_string());
        }
        if let Some(asset_id) =
            Self::as_string(root, &["asset.id", "asset_id", "device.id", "asset"])
        {
            if !assets.contains(&asset_id) {
                assets.push(asset_id);
            }
        }

        Vulnerability {
            id,
            cve_id,
            title: Self::as_string(root, &["title", "name", "vulnerability.title"])
                .unwrap_or_else(|| "Unnamed vulnerability".to_string()),
            description: Self::as_string(
                root,
                &["description", "vulnerability.description", "details"],
            )
            .unwrap_or_else(|| "No description provided".to_string()),
            severity: Self::parse_severity(root),
            cvss_score: Self::as_f32(root, &["cvssScore", "cvss.score", "cvss_v3_score"]),
            cvss_vector: Self::as_string(root, &["cvssVector", "cvss.vector"]),
            affected_asset_ids: assets,
            remediation: Self::as_string(root, &["solution", "remediation", "fix"]),
            exploit_available: Self::as_bool(
                root,
                &["exploits", "exploitAvailable", "exploit_available"],
            )
            .unwrap_or(false),
            patch_available: Self::as_bool(root, &["patchAvailable", "patch_available"])
                .unwrap_or(false),
            first_seen,
            last_seen,
            status: Self::parse_status(root),
        }
    }

    fn parse_scan_status(raw: &str) -> ScanStatus {
        match raw.to_ascii_lowercase().as_str() {
            "running" | "in_progress" => ScanStatus::Running,
            "finished" | "completed" | "done" => ScanStatus::Completed,
            "failed" | "error" => ScanStatus::Failed,
            "cancelled" | "canceled" => ScanStatus::Cancelled,
            _ => ScanStatus::Pending,
        }
    }

    fn parse_scan_result(scan_id: &str, payload: Value) -> ScanResult {
        let scan_view = Self::find_value(&payload, "scan").unwrap_or(&payload);
        let stats_view = Self::find_value(scan_view, "vulnerability_count_by_severity")
            .or_else(|| Self::find_value(scan_view, "severity_counts"));

        ScanResult {
            scan_id: Self::as_string(scan_view, &["id", "scan_id"])
                .unwrap_or_else(|| scan_id.to_string()),
            scan_name: Self::as_string(scan_view, &["name", "scan_name"])
                .unwrap_or_else(|| format!("Scan {}", scan_id)),
            status: Self::as_string(scan_view, &["status"])
                .map(|s| Self::parse_scan_status(&s))
                .unwrap_or(ScanStatus::Pending),
            started_at: Self::as_datetime(scan_view, &["startTime", "started_at"]),
            completed_at: Self::as_datetime(scan_view, &["endTime", "completed_at"]),
            total_hosts: Self::as_usize(scan_view, &["assets", "total_assets", "host_count"])
                .unwrap_or(0),
            vulnerabilities_found: Self::as_usize(
                scan_view,
                &[
                    "vulnerabilities",
                    "vulnerability_count",
                    "total_vulnerabilities",
                ],
            )
            .unwrap_or(0),
            critical_count: stats_view
                .and_then(|v| Self::as_usize(v, &["critical", "4"]))
                .unwrap_or(0),
            high_count: stats_view
                .and_then(|v| Self::as_usize(v, &["high", "3"]))
                .unwrap_or(0),
            medium_count: stats_view
                .and_then(|v| Self::as_usize(v, &["medium", "2"]))
                .unwrap_or(0),
            low_count: stats_view
                .and_then(|v| Self::as_usize(v, &["low", "1"]))
                .unwrap_or(0),
        }
    }
}

#[async_trait]
impl Connector for Rapid7Connector {
    fn name(&self) -> &str {
        &self.config.connector.name
    }

    fn connector_type(&self) -> &str {
        "vulnerability"
    }

    fn capabilities(&self) -> Vec<String> {
        vec![
            "health_check".to_string(),
            "test_connection".to_string(),
            "get_vulnerabilities".to_string(),
            "get_scan_results".to_string(),
        ]
    }

    async fn health_check(&self) -> ConnectorResult<ConnectorHealth> {
        match self.client.get("/api/3/sites?size=1").await {
            Ok(response) if response.status().is_success() => Ok(ConnectorHealth::Healthy),
            Ok(response) if response.status().as_u16() == 401 => Ok(ConnectorHealth::Unhealthy(
                "Authentication failed".to_string(),
            )),
            Ok(response) => Ok(ConnectorHealth::Degraded(format!(
                "Unexpected status code {}",
                response.status()
            ))),
            Err(ConnectorError::ConnectionFailed(err)) => Ok(ConnectorHealth::Unhealthy(err)),
            Err(err) => Ok(ConnectorHealth::Unhealthy(err.to_string())),
        }
    }

    async fn test_connection(&self) -> ConnectorResult<bool> {
        let response = self.client.get("/api/3/sites?size=1").await?;
        Ok(response.status().is_success())
    }
}

#[async_trait]
impl VulnerabilityScanner for Rapid7Connector {
    async fn get_vulnerabilities_for_asset(
        &self,
        asset_id: &str,
    ) -> ConnectorResult<Vec<Vulnerability>> {
        let path = format!(
            "/api/3/assets/{}/vulnerabilities?size=500",
            urlencoding::encode(asset_id)
        );
        let payload = self.get_json(&path).await?;

        Ok(Self::vulnerability_rows(&payload)
            .into_iter()
            .enumerate()
            .map(|(idx, row)| Self::parse_vulnerability(row, Some(asset_id), idx))
            .collect())
    }

    async fn get_scan_results(&self, scan_id: &str) -> ConnectorResult<ScanResult> {
        let path = format!("/api/3/scans/{}", urlencoding::encode(scan_id));
        let payload = self.get_json(&path).await?;
        Ok(Self::parse_scan_result(scan_id, payload))
    }

    async fn get_recent_vulnerabilities(
        &self,
        since: DateTime<Utc>,
        limit: Option<usize>,
    ) -> ConnectorResult<Vec<Vulnerability>> {
        let payload = self.get_json("/api/3/vulnerabilities?size=500").await?;

        let mut vulnerabilities: Vec<_> = Self::vulnerability_rows(&payload)
            .into_iter()
            .enumerate()
            .map(|(idx, row)| Self::parse_vulnerability(row, None, idx))
            .filter(|v| v.last_seen >= since || v.first_seen >= since)
            .collect();

        vulnerabilities.sort_by(|a, b| b.last_seen.cmp(&a.last_seen));

        if let Some(limit) = limit {
            vulnerabilities.truncate(limit);
        }

        Ok(vulnerabilities)
    }

    async fn get_vulnerability_by_cve(
        &self,
        cve_id: &str,
    ) -> ConnectorResult<Option<Vulnerability>> {
        let path = format!("/api/3/vulnerabilities/{}", urlencoding::encode(cve_id));

        match self.get_json(&path).await {
            Ok(payload) => {
                let vulnerability = Self::parse_vulnerability(&payload, None, 0);
                if vulnerability
                    .cve_id
                    .as_ref()
                    .map(|cve| cve.eq_ignore_ascii_case(cve_id))
                    .unwrap_or(false)
                {
                    return Ok(Some(vulnerability));
                }
                Ok(None)
            }
            Err(ConnectorError::NotFound(_)) => Ok(None),
            Err(err) => Err(err),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::traits::AuthConfig;
    use std::collections::HashMap;

    fn test_config() -> Rapid7Config {
        Rapid7Config {
            connector: ConnectorConfig {
                name: "rapid7-test".to_string(),
                base_url: "https://us.api.insight.rapid7.com".to_string(),
                auth: AuthConfig::None,
                timeout_secs: 30,
                max_retries: 0,
                verify_tls: true,
                headers: HashMap::new(),
            },
            region: Some("us".to_string()),
        }
    }

    #[test]
    fn test_connector_name() {
        let connector = Rapid7Connector::new(test_config()).unwrap();
        assert_eq!(connector.name(), "rapid7-test");
        assert_eq!(connector.connector_type(), "vulnerability");
    }

    #[test]
    fn test_connector_capabilities() {
        let connector = Rapid7Connector::new(test_config()).unwrap();
        let caps = connector.capabilities();
        assert!(caps.contains(&"get_vulnerabilities".to_string()));
        assert!(caps.contains(&"get_scan_results".to_string()));
    }

    #[test]
    fn test_parse_vulnerability() {
        let payload = serde_json::json!({
            "id": "rapid7-v-1",
            "cves": ["CVE-2025-2000"],
            "title": "RCE in package",
            "description": "Critical issue",
            "severity": "high",
            "cvssScore": 8.2,
            "firstDiscovered": "2025-01-01T00:00:00Z",
            "lastObserved": "2025-01-02T00:00:00Z",
            "patchAvailable": true
        });

        let vuln = Rapid7Connector::parse_vulnerability(&payload, Some("asset-7"), 0);
        assert_eq!(vuln.id, "rapid7-v-1");
        assert_eq!(vuln.cve_id.as_deref(), Some("CVE-2025-2000"));
        assert_eq!(vuln.severity, VulnSeverity::High);
        assert_eq!(vuln.affected_asset_ids, vec!["asset-7".to_string()]);
        assert!(vuln.patch_available);
    }

    #[test]
    fn test_parse_scan_result() {
        let payload = serde_json::json!({
            "id": 10,
            "name": "Weekly scan",
            "status": "finished",
            "startTime": "2025-01-01T00:00:00Z",
            "endTime": "2025-01-01T00:10:00Z",
            "assets": 25,
            "vulnerabilities": 11,
            "vulnerability_count_by_severity": {
                "critical": 2,
                "high": 3,
                "medium": 4,
                "low": 2
            }
        });

        let result = Rapid7Connector::parse_scan_result("10", payload);
        assert_eq!(result.scan_name, "Weekly scan");
        assert_eq!(result.status, ScanStatus::Completed);
        assert_eq!(result.total_hosts, 25);
        assert_eq!(result.critical_count, 2);
    }
}
